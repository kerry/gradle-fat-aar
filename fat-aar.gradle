import com.android.annotations.NonNull
import com.android.manifmerger.ManifestMerger2
import com.android.manifmerger.ManifestMerger2.Invoker
import com.android.manifmerger.ManifestMerger2.MergeType
import com.android.manifmerger.MergingReport
import com.android.manifmerger.PlaceholderEncoder
import com.android.manifmerger.XmlDocument
import com.android.utils.ILogger
import com.google.common.base.Charsets
import com.google.common.io.Files

/**
 * Fat AAR Lib generator v 0.2.1
 * Target Gradle Version :: 2.2.0
 *
 * Latest version available at https://github.com/adwiv/android-fat-aar
 * Please report issues at https://github.com/adwiv/android-fat-aar/issues
 *
 * This code is in public domain.
 *
 * Use at your own risk and only if you understand what it does. You have been warned ! :-)
 */

buildscript {
    repositories {
        jcenter()
        google()
    }
    dependencies {
        classpath 'com.android.tools.build:manifest-merger:26.2.1'
    }
}

configurations {
    embedded
}

dependencies {
    implementation configurations.embedded
}

// Paths to embedded jar files
ext.embeddedJars = new ArrayList()
// Paths to embedded aar projects
ext.embeddedAarDirs = new ArrayList()
// Embedded aar files dependencies
ext.embeddedAarFiles = new ArrayList<ResolvedArtifact>()
// List of embedded R classes
ext.embeddedRClasses = new ArrayList()

// Change backslash to forward slash on windows
ext.build_dir = buildDir.path.replace(File.separator, '/');
ext.root_dir = project.rootDir.absolutePath.replace(File.separator, '/');
ext.exploded_aar_dir = "$build_dir/intermediates/exploded-aar";
ext.classs_release_dir = "$build_dir/intermediates/javac/release/compileReleaseJavaWithJavac/classes";
//ext.bundle_release_dir = "$build_dir/intermediates/bundles/default";
ext.manifest_aaapt_dir = "$build_dir/intermediates/aapt_friendly_merged_manifests/release/processReleaseManifest/aapt";
ext.generated_rsrc_dir = "$build_dir/generated/not_namespaced_r_class_sources/release/generateReleaseRFile/out";

ext.base_r2x_dir = "$build_dir/fat-aar/release/";

def gradleVersionStr = GradleVersion.current().getVersion();
ext.gradleApiVersion = gradleVersionStr.substring(0, gradleVersionStr.lastIndexOf(".")).toFloat();

println "Gradle version: " + gradleVersionStr;

afterEvaluate {
    // STEP: 1 -> This should be the first to run
    // Creating embeddedAarDirs and embeddedAarFiles list for use in the script.
    // the list of dependency must be reversed to use the right overlay order.
    def dependencies = new ArrayList(configurations.embedded.resolvedConfiguration.firstLevelModuleDependencies)
    dependencies.reverseEach {

        def aarPath = "${root_dir}/aarlibs/${it.moduleName}/build/intermediates/bundles/default";
        it.moduleArtifacts.each {
            artifact ->

                println "ARTIFACT: ${artifact}"
                if (artifact.type == 'aar') {
                    if (!embeddedAarFiles.contains(artifact)) {
                        println "Adding Artifact File into embeddedAarFiles => ${artifact}"
                        embeddedAarFiles.add(artifact)
                    }
                    if (!embeddedAarDirs.contains(aarPath)) {
                        if( artifact.file.isFile() ){
                            println "Artifact file => ${artifact.file}"
                            println "AarPath => ${aarPath}"

                            println "Extracting ${artifact.file} to ${aarPath}"
                            copy {
                                from zipTree( artifact.file )
                                into aarPath
                            }
                        }
                        println "Adding Artifact Dir into embeddedAarDirs: ${aarPath}"
                        embeddedAarDirs.add(aarPath)
                    }
                } else if (artifact.type == 'jar') {
                    def artifactPath = artifact.file
                    if (!embeddedJars.contains(artifactPath))
                        println "Adding Jar Artifact Dir into embeddedJars: ${artifactPath}"
                    embeddedJars.add(artifactPath)
                } else {
                    throw new Exception("Unhandled Artifact of type ${artifact.type}")
                }
        }
    }

    if (dependencies.size() > 0) {
        // Step: 2 -> Setup task dependencies here
        // embedAssets -> generateReleaseAssets
        generateReleaseAssets.dependsOn embedAssets

        // embedLibraryResources -> packageReleaseResources
        packageReleaseResources.dependsOn embedLibraryResources

        // embedJniLibs -> bundleReleaseAar
        bundleReleaseAar.dependsOn embedJniLibs
        embedJniLibs.dependsOn transformNativeLibsWithSyncJniLibsForRelease

        // Merging original manifest after processReleaseManifest in merged_manifests in build dir with library manifests and replacing original with this and aapt_friendly_merged_manifests
        bundleReleaseAar.dependsOn embedManifests
        embedManifests.dependsOn processReleaseManifest

        compileReleaseJavaWithJavac.dependsOn generateRJava

        bundleReleaseAar.dependsOn embedJavaJars
        embedJavaJars.dependsOn compileReleaseJavaWithJavac
    }
}

task embedAssets {
    doLast {
        println "Running FAT-AAR Task :embedAssets"
        embeddedAarDirs.each { aarPath ->
            // Merge Assets
            println "Working on aarPath => ${aarPath}"
            android.sourceSets.main.assets.srcDirs += file("$aarPath/assets")
        }
    }
}

task embedLibraryResources {
    doLast {
        println "Running FAT-AAR Task :embedLibraryResources ===> Fix This"

//        def oldInputResourceSet = processReleaseJavaRes.inputSourceSets
//        mergeResources.conventionMapping.map("inputResourceSets") {
//            getMergedInputResourceSets(oldInputResourceSet)
//        }
    }
}

private List getMergedInputResourceSets(List inputResourceSet) {
    //We need to do this trickery here since the class declared here and that used by the runtime
    //are different and results in class cast error
    def ResourceSetClass = inputResourceSet.get(0).class

    List newInputResourceSet = new ArrayList(inputResourceSet)

    println "getMergedInputResourceSets"

    println embeddedAarDirs
    embeddedAarDirs.each { aarPath ->
        try {
            println aarPath
            def resname
            if (gradleApiVersion >= 2.3f) {
                def parentProject = project.rootProject.name.toString()
                println "parent: "
                println parentProject

                def startIndex = aarPath.indexOf('/' + parentProject)
                def endIndex = aarPath.indexOf('/build/')

                println "start"
                println startIndex
                println "end"
                println endIndex
                if (startIndex < 1 || endIndex < 1)
                    return;
                resname = aarPath.substring(startIndex, endIndex).replace('/', ':')
            }
            else
                resname = (aarPath.split(exploded_aar_dir)[1]).replace('/', ':');
            def rs = ResourceSetClass.newInstance([resname, true] as Object[])
            rs.addSource(file("$aarPath/res"))
            println "ResourceSet is " + rs
            println resname
            newInputResourceSet += rs
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
    }

    return newInputResourceSet
}

task embedJniLibs {
    doLast {
        println "Running FAT-AAR Task :embedJniLibs"

        embeddedAarDirs.each { aarPath ->
            println "======= Copying JNI from $aarPath/jni"
            // Copy JNI Folders
            copy {
                from fileTree(dir: "$aarPath/jni")
                into file("$build_dir/intermediates/jniLibs/release/")
                into file("$build_dir/intermediates/library_and_local_jars_jni/release/")
            }
        }
    }
}

task embedManifests {
    doLast {
        println "Running FAT-AAR Task :embedManifests"

        ILogger mLogger = new MiLogger()
        List libraryManifests = new ArrayList<>()

        embeddedAarDirs.each { aarPath ->
            println "Working on ${aarPath}"
            File dependencyManifest = file("$aarPath/AndroidManifest.xml")

            if (!libraryManifests.contains(aarPath) && dependencyManifest.exists()) {
                println "Adding libraryManifestPath to list"
                libraryManifests.add(dependencyManifest)
            }
        }


        File reportFile = file("${build_dir}/embedManifestReport.txt")

        println "reportFile path => ${reportFile.absolutePath}"

        File origManifest = file("${build_dir}/intermediates/merged_manifests/release/processReleaseManifest/merged/AndroidManifest.xml")

        println "origManifest path => ${origManifest.absolutePath}"

        File copyManifest = file("${build_dir}/intermediates/merged_manifests/release/processReleaseManifest/merged/AndroidManifest.orig.xml")

        println "copyManifest path => ${copyManifest.absolutePath}"

        File aaptManifest = file("$manifest_aaapt_dir/AndroidManifest.xml")

        println "aaptManifest path => ${aaptManifest.absolutePath}"

        if(!origManifest.exists()) {
            origManifest = file("./android/main/AndroidManifest.xml")
        }

        if(!origManifest.exists()) {
            return;
        }

        copy {
            from origManifest.parentFile
            into copyManifest.parentFile
            include origManifest.name
            rename(origManifest.name, copyManifest.name)
        }

        try {
            Invoker manifestMergerInvoker = ManifestMerger2.newMerger(copyManifest, mLogger, MergeType.APPLICATION)

            manifestMergerInvoker.addLibraryManifests(libraryManifests.toArray(new File[libraryManifests.size()]))

            // manifestMergerInvoker.setPlaceHolderValues(placeHolders)
            manifestMergerInvoker.setMergeReportFile(reportFile);

            MergingReport mergingReport = manifestMergerInvoker.merge();

            mLogger.info("Merging result:" + mergingReport.getResult());
            MergingReport.Result result = mergingReport.getResult();
            switch (result) {
                case MergingReport.Result.WARNING:
                    mergingReport.log(mLogger);
            // fall through since these are just warnings.
                case MergingReport.Result.SUCCESS:
                    XmlDocument xmlDocument = mergingReport.getMergedXmlDocument(MergingReport.MergedManifestKind.MERGED);
                    try {
                        String annotatedDocument = mergingReport.getActions().blame(xmlDocument);
                        mLogger.verbose(annotatedDocument);
                    } catch (Exception e) {
                        mLogger.error(e, "cannot print resulting xml");
                    }
                    save(xmlDocument, origManifest);
                    mLogger.info("Merged manifest saved to " + origManifest);
                    if (aaptManifest.exists()) {

                        //TODO :: Prateek :: visit method has different argument than XmlDocument
//                        PlaceholderEncoder.visit(xmlDocument);

                        save(xmlDocument, aaptManifest);
                        mLogger.info("Merged aapt safe manifest saved to " + aaptManifest);
                    }
                    break;
                case MergingReport.Result.ERROR:
                    mergingReport.log(mLogger);
                    throw new RuntimeException(mergingReport.getReportString());
                default:
                    throw new RuntimeException("Unhandled result type : " + mergingReport.getResult());
            }
        } catch (RuntimeException e) {
            // Unacceptable error
            e.printStackTrace()
            throw new RuntimeException(e);
        }
    }
}

task generateRJava {
    doLast {
        println "Running FAT-AAR Task :generateRJava"

        // Now generate the R.java file for each embedded dependency
        def mainManifestFile = android.sourceSets.main.manifest.srcFile;
        def libPackageName = "";

        if(mainManifestFile.exists()) {

            libPackageName = new XmlParser().parse(mainManifestFile).@package
        }

        println "Identified libPackageName as ${libPackageName}"

        embeddedAarDirs.each { aarPath ->

            println "Working on Aar Dir at path => ${aarPath}"
            def manifestFile = file("$aarPath/AndroidManifest.xml");
            if(!manifestFile.exists()) {
                manifestFile = file("./android/main/AndroidManifest.xml");
            }

            if(manifestFile.exists()) {
                def aarManifest = new XmlParser().parse(manifestFile);
                def aarPackageName = aarManifest.@package

                String packagePath = aarPackageName.replace('.', '/')

                // Generate the R.java file and map to current project's R.java
                // This will recreate the class file
                def rTxt = file("$aarPath/R.txt")
                def rMap = new ConfigObject()

                if (rTxt.exists()) {
                    rTxt.eachLine {
                        line ->
                            //noinspection GroovyUnusedAssignment
                            def (type, subclass, name, value) = line.tokenize(' ')
                            rMap[subclass].putAt(name, type)
                    }
                }

                def sb = "package $aarPackageName;" << '\n' << '\n'
                sb << 'public final class R {' << '\n'

                rMap.each {
                    subclass, values ->
                        sb << "  public static final class $subclass {" << '\n'
                        values.each {
                            name, type ->
                                sb << "    public static $type $name = ${libPackageName}.R.${subclass}.${name};" << '\n'
                        }
                        sb << "    }" << '\n'
                }

                sb << '}' << '\n'

                mkdir("$generated_rsrc_dir/$packagePath")
                file("$generated_rsrc_dir/$packagePath/R.java").write(sb.toString())

                embeddedRClasses += "$packagePath/R.class"
                embeddedRClasses += "$packagePath/R\$*.class"
                println "Embedded R Classes => ${embeddedRClasses}"
            }

        }
    }
}

task collectRClass {
    doLast {
        println "COLLECT R CLASS"

        println "Deleting Base R2X Directory"
        delete base_r2x_dir

        println "Creating Base R2X Directory"
        mkdir base_r2x_dir

        println "Copying from: ${classs_release_dir} into ${base_r2x_dir}"
        copy {
            from classs_release_dir
            include embeddedRClasses
            into base_r2x_dir
        }
    }
}

task embedRClass(type: org.gradle.jvm.tasks.Jar, dependsOn: collectRClass) {
    doFirst {
        println "EMBED R CLASS => Type: Jar"
        mkdir "${build_dir}/intermediates/packaged-classes/release/libs"
    }
    baseName "rsource"
    destinationDir file("${build_dir}/intermediates/packaged-classes/release/libs")
    from base_r2x_dir
}

task embedJavaJars(dependsOn: embedRClass) {
    doLast {
        println "Running FAT-AAR Task :embedJavaJars"

        embeddedAarDirs.each { aarPath ->

            // Explode all classes.jar files to classes so that they can be proguarded
            embeddedAarFiles.each {
                artifact ->
                    FileTree aarFileTree = zipTree(artifact.file.getAbsolutePath());

                    def aarFile = aarFileTree.files.find { it.name.contains("classes.jar") }

                    copy {
                        from zipTree(aarFile)
                        into classs_release_dir
                    }
            }

            def embeddedJarPath = file("${aarPath}/libs");
            println "embeddedJarPath => ${embeddedJarPath}"
            if (embeddedJarPath.exists()) {
                copy {
                    from embeddedJarPath
                    include "*.jar"
                    into file("${build_dir}/intermediates/packaged-classes/release/libs")
                }
            }
        }

        copy {
            from embeddedJars
            into file("${build_dir}/intermediates/packaged-classes/release/libs")
        }
    }
}

private void save(XmlDocument xmlDocument, File out) {
    try {
        Files.write(xmlDocument.prettyPrint(), out, Charsets.UTF_8);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}

class MiLogger implements ILogger {

    @Override
    void error(
            @com.android.annotations.Nullable Throwable t,
            @com.android.annotations.Nullable String msgFormat, Object... args) {
        System.err.println(String.format("========== ERROR : " + msgFormat, args))
        if (t) t.printStackTrace(System.err)
    }

    @Override
    void warning(@NonNull String msgFormat, Object... args) {
        System.err.println(String.format("========== WARNING : " + msgFormat, args))
    }

    @Override
    void info(@NonNull String msgFormat, Object... args) {
        System.out.println(String.format("========== INFO : " + msgFormat, args))
    }

    @Override
    void verbose(@NonNull String msgFormat, Object... args) {
        // System.out.println(String.format("========== DEBUG : " + msgFormat, args))
    }
}
